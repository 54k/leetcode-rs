# Алгоритм Тарьяна используется для нахождения компонент сильной связности (КСС) ориентированного графа. Компонента сильной связности — это максимальное подмножество вершин графа, в котором каждая вершина достижима из любой другой вершины.
# 
# Объяснение алгоритма Тарьяна
# Алгоритм Тарьяна основан на глубинном обходе графа (DFS) и использует стек для отслеживания вершин, составляющих текущую компоненту сильной связности. Основная идея алгоритма заключается в следующем:
# 
# Инициализация:
# 
# Заводятся массивы index и lowlink, а также стек stack.
# index отслеживает уникальный индекс каждой вершины.
# lowlink отслеживает наименьший индекс вершины, достижимой из текущей вершины.
# stack используется для хранения вершин текущей компоненты сильной связности.
# Глубинный обход (DFS):
# 
# Для каждой вершины, если она не была посещена, запускается глубинный обход.
# При посещении вершины ей присваивается индекс, и она помещается в стек.
# Обновление lowlink и идентификация КСС:
# 
# После рекурсивного вызова для всех соседей текущей вершины обновляется значение lowlink текущей вершины.
# Если lowlink текущей вершины равно её index, это означает, что текущая вершина является корнем компоненты сильной связности. Вершины извлекаются из стека до тех пор, пока не будет достигнута текущая вершина.
def tarjan_scc(graph):
    index = 0
    stack = []
    indices = {}
    lowlinks = {}
    on_stack = {}
    scc = []

    def strongconnect(v):
        nonlocal index
        indices[v] = index
        lowlinks[v] = index
        index += 1
        stack.append(v)
        on_stack[v] = True

        for w in graph[v]:
            if w not in indices:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif on_stack[w]:
                lowlinks[v] = min(lowlinks[v], indices[w])

        if lowlinks[v] == indices[v]:
            component = []
            while True:
                w = stack.pop()
                on_stack[w] = False
                component.append(w)
                if w == v:
                    break
            scc.append(component)

    for v in graph:
        if v not in indices:
            strongconnect(v)

    return scc
