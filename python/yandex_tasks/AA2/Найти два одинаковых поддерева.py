"""
Дано бинарное дерево с выделенным корнем, в каждой вершине которого записано по одной букве A-Z.
Две вершины считаются эквивалентными, если поддеревья этих вершин содержат одинаковое множество (т.е. без учета частот) букв.
Нужно найти любую пару эквивалентных вершин.
Можно усложнить, задав:
Нужно найти две эквивалентные вершины с максимальным суммарным размером поддеревьев.
"""
"""
Решение за O(NK), где N - размер дерева, K - размер алфавита.
То есть, обход дерева с построением дескриптора (булева массива размера K)
поддерева и отображения - дескриптор->два максимальных поддерева с этим дескриптором.

Можно поддерживать мап из декскриптора в максимальное поддерево с таким дескриптором
и обновлять пару с максимальной суммой каждый раз, когда мы пытаемся обновить в мапе максимум.
Так писать даже проще.
Хороший кандидат в качестве дескриптора использует битовую маску встреченных букв и получит сложность O(N).

псевдокод для идеи

Pair<Node, Node> ans;
int msk(Node current, HashMap<Integer, Node> map) {
    if(current == null) {
        return 0;
    }
    int current_msk = 1 << (Character.getNumericValue(current.value) - Character.getNumericValue('A'));
    int mask = current_msk | msk(current.left, map) | msk(current.right, map);
    Node node = map.get(mask);
    if(node != null) {
        ans = new Pair(current, node);
    }
    map.put(mask, node);
    return mask;
}
"""
